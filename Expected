pipeline {
    agent any
    parameters {
        booleanParam(name: 'permitExecute', defaultValue: false, description: 'Allow execution?')
    }

    stages {
        stage('Check and Abort') {
            steps {
                script {
                    if (!params.permitExecute) {
                        abortAndDeleteBuild()
                    } else {
                        echo "Execution permitted. Proceeding with the build."
                    }
                }
            }
        }
        stage('Continue Build') {
            when {
                expression { params.permitExecute == true }
            }
            steps {
                echo "Build is running..."
                // Add actual build steps here
            }
        }
    }
}

// Function to abort and delete the build
def abortAndDeleteBuild() {
    try {
        def buildNumber = env.BUILD_NUMBER.toInteger()
        def jobName = env.JOB_NAME

        echo "Checking if build #${buildNumber} of job '${jobName}' should be aborted and deleted."

        def jenkins = Jenkins.instanceOrNull
        if (jenkins == null) {
            error("Jenkins instance is not available.")
        }

        def job = jenkins.getItemByFullName(jobName)
        if (job == null) {
            error("Job '${jobName}' not found.")
        }

        // Mark the build as aborted
        currentBuild.result = hudson.model.Result.ABORTED
        echo "Build #${buildNumber} marked as ABORTED."

        sleep(5) // Wait for 5 seconds before deletion

        // Delete the build
        def build = job.getBuildByNumber(buildNumber)
        if (build) {
            build.delete()
            echo "Build #${buildNumber} deleted successfully."
        } else {
            echo "Build #${buildNumber} not found for deletion."
        }
    } catch (Exception e) {
        echo "Error: ${e.getMessage()}"
    }
}
